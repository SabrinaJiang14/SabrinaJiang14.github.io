<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sabrinajiang14.github.io/</id>
    <title>Sab.J 的碼農世界</title>
    <updated>2020-01-10T06:02:57.273Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sabrinajiang14.github.io/"/>
    <link rel="self" href="https://sabrinajiang14.github.io/atom.xml"/>
    <subtitle>喜歡看看新技術，了解新架構，正在往Clean Code的方向前進…</subtitle>
    <logo>https://sabrinajiang14.github.io/images/avatar.png</logo>
    <icon>https://sabrinajiang14.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Sab.J 的碼農世界</rights>
    <entry>
        <title type="html"><![CDATA[[Swift] 重構路遙遙無期之Router]]></title>
        <id>https://sabrinajiang14.github.io/post/chong-gou-lu-yao-yao-wu-qi-zhi-router</id>
        <link href="https://sabrinajiang14.github.io/post/chong-gou-lu-yao-yao-wu-qi-zhi-router">
        </link>
        <updated>2019-12-18T14:46:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>最近公司給了一個新項目，說是要在過年前完成(又是一個不可能的任務...)<br>
說是要從另外一份搬過來，皮換一換就好(更別說公司的 UI 設計的圖有多奇耙，我都不敢承認我是 app rd 了...)</p>
<p>但是，事情從來都不是這麼簡單...</p>
<p>看了看原本的 source code 後，雖然說換皮而已，但是基本上我覺得就是跟重寫差不多<br>
一如往常的 MVC 架構，UI、business logic、API 等等，全部都在 ViewController 裡面啊!<br>
說是要換皮，還真不知道要從哪邊下手。<br>
忽然間我想起 <code>Router</code> 這個東西，可以在幾乎不動原本架構下將<strong>頁面跳轉</strong>這件事統一到某個地方處理，也比較符合 <code>單一職責原則 Single Responsibility Principle (SRP)</code> (雖然很想全部重構...)</p>
<hr>
<h2 id="正文開始">正文開始</h2>
<h3 id="router">Router</h3>
<p>主要的思路會是將<strong>頁面跳轉</strong>這件事統一到一個地方處理，例如說：Router這個物件身上，<br>
也因為他幾乎是跨頁面存在，所以我這邊會將他設計成 Singleton 物件。<br>
也會在一開始設定一個新的 root view controller (navigation controller) ，去貫穿整個App的走向。</p>
<pre><code>final class Router:NSObject {
    static let instance = Router()
    override init() {
        super.init()
    }

    private var rootController: UINavigationController?
    func setRootViewController(rootController:UINavigationController) {
        self.rootController = rootController
    }
}
</code></pre>
<p>一個簡單的 Router 雛形就出來了。<br>
接下來我會加入一個 enum，這個 enum 裡面有包含所有的 ViewController 的 case，另外會有一個 getViewController 的 function 去將這個 ViewController 的實體回傳。</p>
<pre><code>enum RouterView : Equatable {
        case home
        case login
        case register
        case member
        case updatePwd
        .
        .
        .
}
</code></pre>
<pre><code>private func getViewController(_ view:RouterView) -&gt; UIViewController? {
        var controller:UIViewController?
        switch view {
            case .home:
                let storyboard = UIStoryboard(name: &quot;Home&quot;, bundle: nil)
                let vc = storyboard.instantiateViewController(identifier: &quot;HomeViewController&quot;) as! HomeViewController
                controller = vc
            ...
        }
        return controller
}
</code></pre>
<p>通常頁面跳轉會有幾個方式：<code>PUSH &amp; PRESENT</code> ，所以我們就要在 Router 裡面實作如何跳轉頁面的功能。</p>
<pre><code>func show(_ view:RouterView) {
        guard let navi = rootController else {
            fatalError(&quot;call setRootViewController(rootController:) first&quot;)
        }
        guard let controller:UIViewController = getViewController(view) else {
            return
        }
        DispatchQueue.main.async {
            controller.hidesBottomBarWhenPushed = true
            navi.setNavigationBarHidden(false, animated: true)
            navi.show(controller, sender: nil)
        }
    }
    
    func present(_ view:RouterView) {
        guard let navi = rootController else {
            fatalError(&quot;call setRootViewController(rootController:) first&quot;)
        }
        guard let controller:UIViewController = getViewController(view) else {
            return
        }
        presentView(navi, controller: controller)
    }
</code></pre>
<p>到這邊為止就把一個基本的 Router 的架構建好，以後如果要新增轉跳的頁面時，就到這個地方加上新的 enum 跟實體的 ViewController。<br>
而且原本的 ViewController 也只要一句話就完成了，是不是超棒der ~</p>
<pre><code>Rounter.instance.show(.home)
</code></pre>
<p>或是</p>
<pre><code>Router.instance.present(.updatePwd)
</code></pre>
<hr>
<p>到這邊，你搞不好會問，這個 Router 只做這樣的功能，感覺沒有很吸引其他工程師做這些改變。<br>
如果是我，我也覺得誘因不大。</p>
<p>但是，我覺得最最重要的是接下來要講的這個東西。</p>
<p>每個 app rd 一定會碰到一個流程就是：當使用者點選某幾個頁面時，要檢查是不是登入狀態，如果沒有就要跳出登入的畫面做登入。</p>
<p>那原本的作法就會是在每個 ViewController 要去轉跳前檢查是不是登入狀態。<br>
那如果有15個地方要檢查就要寫15次，如果有200個地方就要寫200次... (我的人生很寶貴，不想浪費時間在這上面)<br>
而且如果檢查的邏輯有改變呢 ？？？</p>
<p>所以在這個 Router 裡面，我多加了一個 Check 的 function，把檢查的邏輯統一到這裡面，<br>
以後邏輯有改也只要到這裡面改就可以囉~~</p>
<pre><code>class RouterCheck:NSObject {
    
    lazy var controllers:[Router.RouterView] = {
        return [.member, .updatePwd]
    }()
    
    override init() {
        super.init()
    }
    
    func isNeedsLogin(accountStatus:Bool, toView:Router.RouterView) -&gt; Bool {
        if controllers.filter({ $0 == toView }).count &gt; 0 &amp;&amp; accountStatus != true {
            return true
        } else {
            return false
        }
    }
}
</code></pre>
<p>在 getViewcontroller() 裡面加入這個檢查</p>
<pre><code>if checker.isNeedsLogin(accountStatus: ... , toView: view) {
    return nil
}
</code></pre>
<p>到這邊就完成了 Router 的實作以及不破壞現有架構進行的重構。<br>
我個人覺得 Router 的好處就是跳轉頁面跟跳轉頁面檢查可以統一在一個地方處理就好，不用撒的到處都是囉。</p>
<p>完整的 code 請看下方。<br>
希望這篇對大家有幫助 ^^</p>
<pre><code>final class Router:NSObject {
    enum RouterView : Equatable {
        case home
        case login
        case register
        case member
        case updatePwd
        .
        .
        .
    }

    static let instance = Router()
    override init() {
        super.init()
    }

    private var rootController: UINavigationController?
    func setRootViewController(rootController:UINavigationController) {
        self.rootController = rootController
    }

    func show(_ view:RouterView) {
        guard let navi = rootController else {
            fatalError(&quot;call setRootViewController(rootController:) first&quot;)
        }
        guard let controller:UIViewController = getViewController(view) else {
            let login = LoginCheckViewController() 
            presentView(navi, controller: login)
            return
        }
        DispatchQueue.main.async {
            controller.hidesBottomBarWhenPushed = true
            navi.setNavigationBarHidden(false, animated: true)
            navi.show(controller, sender: nil)
        }
    }
    
    func present(_ view:RouterView) {
        guard let navi = rootController else {
            fatalError(&quot;call setRootViewController(rootController:) first&quot;)
        }
        guard let controller:UIViewController = getViewController(view) else {
            let login = LoginCheckViewController() 
            presentView(navi, controller: login)
            return
        }
        presentView(navi, controller: controller)
    }
    
    private func presentView(_ navi:UINavigationController, controller:UIViewController) {
        DispatchQueue.main.async {
            controller.hidesBottomBarWhenPushed = true
            navi.present(controller, animated: true, completion: nil)
        }
    }

    private func getViewController(_ view:RouterView) -&gt; UIViewController? {
        var controller:UIViewController?
        if checker.isNeedsLogin(accountStatus: ... , toView: view) {
            return nil
        }
        switch view {
            case .home:
                let storyboard = UIStoryboard(name: &quot;Home&quot;, bundle: nil)
                let vc = storyboard.instantiateViewController(identifier: &quot;HomeViewController&quot;) as! HomeViewController
                controller = vc
            ...
        }
        return controller
    }
}


class RouterCheck:NSObject {
    
    lazy var controllers:[Router.RouterView] = {
        return [.member, .updatePwd]
    }()
    
    override init() {
        super.init()
    }
    
    func isNeedsLogin(accountStatus:Bool, toView:Router.RouterView) -&gt; Bool {
        if controllers.filter({ $0 == toView }).count &gt; 0 &amp;&amp; accountStatus != true {
            return true
        }else{
            return false
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[iOS] 憑證的來龍去脈]]></title>
        <id>https://sabrinajiang14.github.io/post/ios-ping-zheng-de-lai-long-qu-mo</id>
        <link href="https://sabrinajiang14.github.io/post/ios-ping-zheng-de-lai-long-qu-mo">
        </link>
        <updated>2019-11-26T09:46:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>說到這個憑證，一直以來都是我很頭大的一個項目。只知道要從電腦裡面匯出 CSR，然後下載 .cer 檔案，還要下載 provision profile 等。就是一些很不直覺的動作。</p>
<p>後來不知道 Xcode 第幾版後開始支援 <strong>Automatically manage signing</strong><br>
<img src="https://sabrinajiang14.github.io//post-images/1574761850597.png" alt="" loading="lazy"></p>
<p>開心到睡不著啦😆😆😆，只要一勾起來就什麼煩惱都沒有了啊！！當下覺得這真的是這世界上最偉大的發明了啊～～～</p>
<p><strong>But, 就是這個 But</strong>...<br>
就在某一次的面試當中被洗臉之後，我發現還是不能這樣得過且過，還是要認真把憑證搞清楚...</p>
<hr>
<p>了解憑證之前，要先知道什麼是 <code>非對稱式加密</code>，詳情請看➡️<a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">維基百科</a> ⬅️。</p>
<p>看完非對稱式加密後，就可以來看看用戶版的 app 下載與驗證的過程</p>
<h2 id="用戶版">用戶版</h2>
<p>在每個 iOS 裝置出廠時就配置好一把 Apple 產出的公鑰，而私鑰就由 Apple 自己保管著。當開發者將開發好的 App 上傳到 Apple 時，Apple 就會用他的私鑰對 App 加密。而用戶透過 App Store 下載 App，裝置上的公鑰就會對 App 進行驗證，若驗證成功表示這個 App 沒有修改過，就會進行安裝。<code>也就是每一個 App 都是通過 Apple 官方允許可以正常安裝在裝置上的。</code></p>
<hr>
<h2 id="開發者版">開發者版</h2>
<h3 id="csr-cer">CSR / CER</h3>
<p>但是在開發過程中，開發者會需要不斷的除錯或是增加新功能，總不能每次開發到一個階段就要送到 App Store 下載驗證吧！所以這時候就又多了一個開發者專用的流程。<br>
Mac 系統自帶一組公鑰 &amp; 私鑰，當我們從 Keychain Access 匯出 CSR 檔時，裡面帶有開發者及公鑰等相關資訊。<br>
<img src="https://sabrinajiang14.github.io//post-images/1574833912000.png" alt="" loading="lazy"><br>
<img src="https://sabrinajiang14.github.io//post-images/1574833745851.png" alt="" loading="lazy"><br>
接下來，我們需要把 CSR 上傳到 Certificates ，同時 Apple 會用私鑰對 CSR 進行加密，我們再把 .cer 檔下載回來後點擊兩下後安裝到電腦裡面。回到 Keychain Access 可以看到原本的 .cer 檔跟我們的私鑰綁再一起。</p>
<h3 id="provisioning-profile">Provisioning Profile</h3>
<p>當我們設定好 Identifiers &amp; Devices 來到 Provisioning Profile 這區新增一個 Profile。下載開發者設定好的 xxx.mobileprovision 檔後導出 .plist 就會看到這個檔案裡面包含了 AppIDName, TeamIdentifier, UUID, application-identifier 等資訊。</p>
<pre><code>security cms -D -i your provisioning name.mobileprovision -o provision.plist
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://sabrinajiang14.github.io//post-images/1574838160304.png" alt="" loading="lazy"></figure>
<pre><code>AppIDName &gt; App 的名稱
TeamIdentifier &gt; 憑證編號
UUID &gt; 註冊的裝置
application-identifier &gt; 這個是 app 的身份辨識碼。是憑證編號 + Bundle Indetifier
(所以如果今天你是用企業簽的 app，發現無法覆蓋安裝時，應該就是他的憑證編號或是 Bundle Indetifier換了)
</code></pre>
<p>企業憑證跟個人憑證基本上沒有什麼差別，最大的差別在於 UUID， Apple 限制個人開發者最多只能有100個實體裝置，而企業憑證沒有這個限制。<br>
所以在這個 xxx.mobileprovision 裡面看到的是 <code>ProvisionsAllDevices</code> 而非單一裝置的 uuid。</p>
<h3 id="打包">打包</h3>
<p>現在萬事俱備，只缺東風啦！</p>
<p>打包時，Xocde 會拿出電腦的私鑰將 app 加密，同時將 xxx.mobileprovision 改名為embedded.mobileprovision，把 .cer &amp; embedded.mobileprovision 放到名為 Payload 的資料夾裡並包成xxx.ipa。<br>
iPhone 在安裝 app 時會從 ipa 裡面取出 .cer 檔，透過 iPhone 裡面的公鑰進行驗證其正確性。而在透過 .cer 裡面的 CSR 檔去驗證這個App的正確性，確認無誤後再檢查 embedded.mobileprovision，確認這隻手機的 uuid 有包含在檔案裡面才能正常安裝在該裝置上。</p>
<hr>
<p>參考文件：<br>
<a href="http://xelz.info/blog/2019/01/11/ios-code-signature/">深度长文：细说iOS代码签名</a> (非常推薦👍👍👍)<br>
<a href="https://juejin.im/post/5dac01e6f265da5b64649e6b">iOS 应用签名原理及重签技术</a><br>
<a href="https://www.jianshu.com/p/4f6245fa2e3c">iOS-签名机制和证书原理</a><br>
<a href="http://blog.cnbang.net/tech/3386/">iOS App 签名的原理</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Test] iOS 自動化測試之好用工具 — Appium]]></title>
        <id>https://sabrinajiang14.github.io/post/ios-zi-dong-hua-ce-shi-zhi-hao-yong-gong-ju-appium</id>
        <link href="https://sabrinajiang14.github.io/post/ios-zi-dong-hua-ce-shi-zhi-hao-yong-gong-ju-appium">
        </link>
        <updated>2019-11-25T06:23:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id=""></h2>
<p>第一次聽到 Appium 這個詞是在 2016 年的時候，當下覺得這東西真好玩，馬上就想試試。但是我光是第一步安裝就被難倒，只好默默把這個關鍵字收藏起來，等到某一天有閒暇時再來研究。</p>
<p>事隔三年多，最近比較有點空閒了。又忽然想到這東西。想說是該來研究一下了。不過在安裝過程還是遇到一些坑，還是順手把它記下，以備不時之需。</p>
<hr>
<h2 id="appium-安裝簡介">Appium 安裝簡介</h2>
<blockquote>
<p>注意：以下的每個步驟卻一不可唷！</p>
</blockquote>
<p><code>環境：macOS Mojave(10.14.6)、Xcode 10.3</code></p>
<h3 id="step-1">Step 1</h3>
<p>打開 Terminal，輸入 <code>java -version</code> ，檢查是否有安裝 Java（如果沒有安裝過的，記得到 Oracle 找最新的 Java 版本安裝，點此到<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk13-downloads-5672538.html">官網</a>）<br>
<img src="https://sabrinajiang14.github.io//post-images/1574749934230.png" alt="" loading="lazy"></p>
<p align=center><font size=1>(圖片取自 Oracle 官網)</font></p>
<p>如果有安裝了，應該會顯示這些訊息<br>
<img src="https://sabrinajiang14.github.io//post-images/1574750032945.png" alt="" loading="lazy"></p>
<h3 id="step-2">Step 2</h3>
<p>輸入 <code>git --version</code> 檢查是否有安裝 Git（如果沒有安裝過，也可以參考<a href="https://git-scm.com/book/zh-tw/v2/%E9%96%8B%E5%A7%8B-Git-%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8">這篇文章</a>安裝 Git）<br>
<img src="https://sabrinajiang14.github.io//post-images/1574750125425.png" alt="" loading="lazy"></p>
<h3 id="step-3">Step 3</h3>
<p>輸入 <code>ruby -v</code> 檢查是否有安裝 ruby<br>
<img src="https://sabrinajiang14.github.io//post-images/1574750190041.png" alt="" loading="lazy"></p>
<h3 id="step-4">Step 4</h3>
<p>安裝brew，請輸入</p>
<pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 
</code></pre>
<h3 id="step-5">Step 5</h3>
<p>安裝 Xcode ，畢竟 Appium 還是在 Xcode 的基礎上做測試，所以還是要安裝。</p>
<h3 id="step-6">Step 6</h3>
<p>安裝 node，請輸入 <code>brew install node</code><br>
但是在這一步一直失敗，訊息提示寫入失敗或是找不到這個資料夾。查了很多資料之後，發現應該是權限有問題，所以我先做以下步驟：</p>
<pre><code>brew uninstall node                         #移除 node
sudo chown -R $(whoami) $(brew — prefix)/*  #權限重新設定
brew install node                           #重新安裝 node
brew link node                              #再重下指令
brew link — overwrite node                  #如果還是失敗，就改成這句
</code></pre>
<p>再打一次 <code>bash node -v</code>，如果成功應該就會顯示下面的資訊<br>
<img src="https://sabrinajiang14.github.io//post-images/1574750699412.png" alt="" loading="lazy"></p>
<h3 id="step-7">Step 7</h3>
<p>安裝 Appium</p>
<pre><code>npm install -g appium   #安裝Server
npm install wd          #安裝Client
</code></pre>
<p>另外，也可以裝個檢查器，檢查 Appium 是否安裝完成。</p>
<pre><code>npm install appium-doctor -g    #安裝檢查器
appium-doctor                   #進行檢查
</code></pre>
<p><img src="https://sabrinajiang14.github.io//post-images/1574751083574.png" alt="" loading="lazy"><br>
<img src="https://sabrinajiang14.github.io//post-images/1574751088658.png" alt="" loading="lazy"><br>
檢查器會將預計會用到的全部檢查一遍，就算不是全部都過，也不用擔心。只要確定自己要測試的那個平台的相關軟體有安裝完成就可以囉。</p>
<h3 id="step8">Step8</h3>
<p>安裝 Appium Desktop<br>
可以直接透過<a href="http://appium.io/">官網</a>下載或是到他們的 <a href="https://github.com/appium/appium-desktop/releases/download/v1.15.1/Appium-mac-1.15.1.dmg">Github</a> 去下載 Appium-mac-x.x.dmg（目前我看到最新版是這個，連結隨時都有可能換，還是從官網連過去最保險）</p>
<p>以上步驟如果都完成了，就可以打開 Appium Desktop<br>
<img src="https://sabrinajiang14.github.io//post-images/1574751218258.png" alt="" loading="lazy"></p>
<p>點選 Start Server 後會顯示另外一個畫面。<br>
<img src="https://sabrinajiang14.github.io//post-images/1574751250657.png" alt="" loading="lazy"></p>
<p>點下右上角的搜尋圖示 — Start Inspector Session<br>
<img src="https://sabrinajiang14.github.io//post-images/1574751270624.png" alt="" loading="lazy"></p>
<p>在這個新的畫面上可以做一些設定，像我是要測試 iOS app。所以我就填上 platformName、platformVersion、autommationName等等相關訊息。（想知道有哪些關鍵字可以填，直接點下方的 Desired Capabilities Documentation 去查看）<br>
完成後可以將此次的測試資料儲存起來，以期下次在使用。點選 Start Session 後就會看到模擬器被啟動囉！<br>
（話說我還有實機的部分還沒有實作，等我實作完再上來補:P）</p>
<hr>
<p>今天這篇文章沒有寫的很專業，只能說是簡單的入門篇而已，希望有幫助到想要入門的朋友唷！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[工商] Marquee For App]]></title>
        <id>https://sabrinajiang14.github.io/post/gong-shang-marquee-for-app</id>
        <link href="https://sabrinajiang14.github.io/post/gong-shang-marquee-for-app">
        </link>
        <updated>2019-09-24T09:21:42.000Z</updated>
        <content type="html"><![CDATA[<p>不知道為啥，這個在web界很紅的小元件，現在在app裡也要參一腳。UI都指定了，我只好來找找有沒有好用的套件。</p>
<p>找了很久發現都沒有好用的，不然就是功能太過複雜。<br>
所以我後來只好跟著安著的復刻iOS版</p>
<figure data-type="image" tabindex="1"><img src="https://sabrinajiang14.github.io//post-images/1574760475357.png" alt="" loading="lazy"></figure>
<p><a href="https://github.com/SabrinaJiang14/MarqueeLabel">連結</a>在此<br>
覺得不錯的朋友，就直接拿去用吧^^</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[OC] Create countdown circle]]></title>
        <id>https://sabrinajiang14.github.io/post/oc-create-countdown-circle</id>
        <link href="https://sabrinajiang14.github.io/post/oc-create-countdown-circle">
        </link>
        <updated>2017-05-11T08:24:29.000Z</updated>
        <content type="html"><![CDATA[<pre><code>//
//  CircleView.h
//
//  Created by Sabrina on 2017/5/12.
//  Copyright © 2017年 Sabrina All rights reserved.
//

#import &lt;UIKit/UIKit.h&gt;

@interface CircleView : UIView

@property (nonatomic) CGFloat precent;

- (id)initWithFrame:(CGRect)frame arcWidth:(double)width;

@end
</code></pre>
<pre><code>//
//  CircleView.m
//
//  Created by Sabrina on 2017/5/12.
//  Copyright © 2017年 Sabrina All rights reserved.
//

#import &quot;CircleView.h&quot;

@implementation CircleView{
	CGFloat startAngle;
	CGFloat endAngle;
	CGFloat circlewWidth, lineWith;
}


- (id)initWithFrame:(CGRect)frame arcWidth:(double)width
{
	
	self = [super initWithFrame:frame];
	
	if (self) {
		// Initialization code

		self.backgroundColor = [UIColor clearColor];
		
		// Determine our start and stop angles for the arc (in radians)
		startAngle = M_PI * 1.5;
		endAngle = startAngle + (M_PI * 2);
		circlewWidth = self.frame.size.width - 20;
		lineWith = self.frame.size.width / 2;
		
	}
	
	return self;
	
}

- (void)drawRect:(CGRect)rect {
	
	UIBezierPath *circle = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(10, 10, circlewWidth, circlewWidth)];
	[[UIColor blueColor] setStroke];
	circle.lineWidth = 0;
	[circle stroke];
	[[UIColor whiteColor] setFill];
	[circle fill];
	
	UIBezierPath *arcLine = [UIBezierPath bezierPathWithArcCenter:CGPointMake(lineWith, lineWith) radius:circlewWidth / 2 startAngle:startAngle endAngle:(endAngle - startAngle) * (self.precent / 100.0) + startAngle clockwise:YES];
	arcLine.lineWidth = 10;
	[[UIColor colorWithRed:145/255.0 green:197/255.0 blue:226/255.0 alpha:1.0] setStroke];
	[arcLine stroke];
	
	NSString* textContent = @&quot;&quot;;
	
	if (self.precent &gt; 100.0){
		textContent = [NSString stringWithFormat:@&quot;%@%%&quot;, @&quot;100&quot;];
	}else{
		textContent = [NSString stringWithFormat:@&quot;%.1f%%&quot;, self.precent];
	}
	
	// Text Drawing
	CGRect textRect = CGRectMake((rect.size.width / 2.0)/2.0, (rect.size.height / 2.0) - 45/2.0, circlewWidth, 45);
	[[UIColor colorWithRed:145/255.0 green:197/255.0 blue:226/255.0 alpha:1.0] setFill];
	NSDictionary *attributes = @{ NSFontAttributeName: [UIFont fontWithName: @&quot;Helvetica-Bold&quot; size: 30.0],
								  NSForegroundColorAttributeName : [UIColor colorWithRed:145/255.0 green:197/255.0 blue:226/255.0 alpha:1.0]};
	[textContent drawInRect:textRect withAttributes:attributes];
}

@end
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[工商] SJDatePicker]]></title>
        <id>https://sabrinajiang14.github.io/post/gong-shang-sjdatepicker</id>
        <link href="https://sabrinajiang14.github.io/post/gong-shang-sjdatepicker">
        </link>
        <updated>2017-04-25T07:53:31.000Z</updated>
        <content type="html"><![CDATA[<p>最近大家都一直在討論說，一個優秀的工程師，除了本身的技術，以及要有一顆保持不斷學習的心之外，應該還要有辦法留一些什麼作品集或是工具包之類的東西。<br>
一方面是當又遇到類似的 UI 或是實作時可以快速拿出應用，不用再重新刻輪子了。<br>
所以我就把我這個做的這一個 Picker 放到 github 上。</p>
<p>如果有興趣的朋友，也可以直接拿去用^^</p>
<figure data-type="image" tabindex="1"><img src="https://sabrinajiang14.github.io//post-images/1574755709723.png" alt="" loading="lazy"></figure>
<p><a href="https://github.com/SabrinaJiang14/SJDatePicker">連結</a>在此</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Swift] Observer Pattern 2 - KVO]]></title>
        <id>https://sabrinajiang14.github.io/post/swift-observer-pattern-2-kvo</id>
        <link href="https://sabrinajiang14.github.io/post/swift-observer-pattern-2-kvo">
        </link>
        <updated>2017-04-13T07:46:05.000Z</updated>
        <content type="html"><![CDATA[<p>重點</p>
<ol>
<li>只支援 NSObject 的子物件</li>
<li>要加入關鍵字 dynamic</li>
</ol>
<pre><code>class album: NSObject {
    dynamic var id:String?
    dynamic var name:String?
    dynamic var url:String?
}
</code></pre>
<pre><code>class ViewController: UIViewController {

    let ab:album = album()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view, typically from a nib.
        ab.id = &quot;0&quot;
        ab.name = &quot;album1&quot;
        ab.url = &quot;http://www.apple.com.tw&quot;
        
        ab.addObserver(self, forKeyPath: &quot;url&quot;, options: [.old,.new], context: nil)
    }

    override func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        
        ab.removeObserver(self, forKeyPath: &quot;url&quot;)
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }

    func Button_Click(_ sender: Any) {
        ab.url = &quot;http://www.google.com.tw&quot;
    }

    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        if keyPath == &quot;url&quot;{
            var newStr:String = &quot;&quot;, oldStr:String = &quot;&quot;
            
            if let dict = change?[.newKey] {
                newStr = dict as! String
            }
            if let dict = change?[.oldKey]{
                oldStr = dict as! String
            }
            print(&quot;old value = \(oldStr) -&gt; new value = \(newStr)&quot;)
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Swift] Observer Pattern 1 - NSNotificationCenter]]></title>
        <id>https://sabrinajiang14.github.io/post/swift-observer-pattern-nsnotificationcenter</id>
        <link href="https://sabrinajiang14.github.io/post/swift-observer-pattern-nsnotificationcenter">
        </link>
        <updated>2017-04-13T07:38:56.000Z</updated>
        <content type="html"><![CDATA[<p>Swift 的觀察者模式實作：</p>
<pre><code>static let CHANGE_BACKGROUND_COLOR = &quot;changeBackgroundColor&quot;

func viewDidLoad(){
  super.viewDidLoad()
  
  //加入觀察者
  NSNotificationCenter.defaultCenter().addObserver(self, selector: #selector(changeBackgroundColor), name: CHANGE_BACKGROUND_COLOR, object: nil)
}

//移除觀察者
func viewWillDisappear(animated: Bool){
  NSNotificationCenter.defaultCenter().removeObserver(self, name: CHANGE_BACKGROUND_COLOR, object: nil)
}

//實作
func changeBackgroundColor(){
  self.view.backgroundColor = UIColor.redColor()
}
</code></pre>
<pre><code>func button_Click(){
  NSNotificationCenter.defaultCenter().postNotificationName(viewcontroller.CHANGE_BACKGROUND_COLOR, object: nil)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[OC] 如何簡單劃出一條線]]></title>
        <id>https://sabrinajiang14.github.io/post/oc-ru-he-jian-dan-hua-chu-yi-tiao-xian</id>
        <link href="https://sabrinajiang14.github.io/post/oc-ru-he-jian-dan-hua-chu-yi-tiao-xian">
        </link>
        <updated>2016-07-20T07:35:18.000Z</updated>
        <content type="html"><![CDATA[<pre><code>UIImageView *imageView1 = [[UIImageView alloc]initWithFrame:CGRectMake(0, 200, 320, 20)];
[self.view addSubview:imageView1];

UIGraphicsBeginImageContext(imageView1.frame.size);   //开始画线
[imageView1.image drawInRect:CGRectMake(0, 0, imageView1.frame.size.width, imageView1.frame.size.height)];
CGContextSetLineCap(UIGraphicsGetCurrentContext(), kCGLineCapRound);  //设置线条终点形状
    
const CGFloat lengths[] = {5,3};
CGContextRef line = UIGraphicsGetCurrentContext();
CGContextSetStrokeColorWithColor(line, [UIColor redColor].CGColor);

CGContextSetLineDash(line, 0, lengths, 2);  //画虚线
CGContextMoveToPoint(line, 0.0, 20.0);    //开始画线
CGContextAddLineToPoint(line, 310.0, 20.0);
CGContextStrokePath(line);

imageView1.image = UIGraphicsGetImageFromCurrentImageContext();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[OC] New UIAlertController]]></title>
        <id>https://sabrinajiang14.github.io/post/oc-new-uialertcontroller</id>
        <link href="https://sabrinajiang14.github.io/post/oc-new-uialertcontroller">
        </link>
        <updated>2016-03-07T07:32:09.000Z</updated>
        <content type="html"><![CDATA[<p>今年開始 Alert view 有新的寫法了。</p>
<p>需要改成用 UIAlertController 的方式去實作，不然就會得到警告喔！</p>
<pre><code>UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;刪除&quot; message:@&quot;確定要刪除？&quot; preferredStyle:UIAlertControllerStyleAlert];
UIAlertAction *sureAction = [UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * action) {
  //裡面實作
}];
UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@&quot;Cancel&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * action) {
  //裡面實作
}];
[alert addAction:sureAction];
[alert addAction:cancelAction];
[self presentViewController:alert animated:YES completion:nil];
</code></pre>
]]></content>
    </entry>
</feed>