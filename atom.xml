<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sabrinajiang14.github.io/</id>
    <title>Sab.J 的碼農世界</title>
    <updated>2019-11-26T07:44:21.813Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sabrinajiang14.github.io/"/>
    <link rel="self" href="https://sabrinajiang14.github.io//atom.xml"/>
    <subtitle>喜歡看看新技術，了解新架構，正在往Clean Code的方向前進…</subtitle>
    <logo>https://sabrinajiang14.github.io//images/avatar.png</logo>
    <icon>https://sabrinajiang14.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Sab.J 的碼農世界</rights>
    <entry>
        <title type="html"><![CDATA[[Test] iOS 自動化測試之好用工具 — Appium]]></title>
        <id>https://sabrinajiang14.github.io//post/ios-zi-dong-hua-ce-shi-zhi-hao-yong-gong-ju-appium</id>
        <link href="https://sabrinajiang14.github.io//post/ios-zi-dong-hua-ce-shi-zhi-hao-yong-gong-ju-appium">
        </link>
        <updated>2019-11-25T06:23:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id=""></h2>
<p>第一次聽到 Appium 這個詞是在 2016 年的時候，當下覺得這東西真好玩，馬上就想試試。但是我光是第一步安裝就被難倒，只好默默把這個關鍵字收藏起來，等到某一天有閒暇時再來研究。</p>
<p>事隔三年多，最近比較有點空閒了。又忽然想到這東西。想說是該來研究一下了。不過在安裝過程還是遇到一些坑，還是順手把它記下，以備不時之需。</p>
<hr>
<h2 id="appium-安裝簡介">Appium 安裝簡介</h2>
<blockquote>
<p>注意：以下的每個步驟卻一不可唷！</p>
</blockquote>
<h3 id="step-1">Step 1</h3>
<p>打開 Terminal，輸入 <code>bash java -version</code> ，檢查是否有安裝 Java（如果沒有安裝過的，記得到 Oracle 找最新的 Java 版本安裝，點此到<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk13-downloads-5672538.html">官網</a>）<br>
<img src="https://sabrinajiang14.github.io//post-images/1574749934230.png" alt=""></p>
<p align=center><font size=1>(圖片取自 Oracle 官網)</font></p>
<p>如果有安裝了，應該會顯示這些訊息<br>
<img src="https://sabrinajiang14.github.io//post-images/1574750032945.png" alt=""></p>
<h3 id="step-2">Step 2</h3>
<p>輸入 <code>bash git --version</code> 檢查是否有安裝 Git（如果沒有安裝過，也可以參考<a href="https://git-scm.com/book/zh-tw/v2/%E9%96%8B%E5%A7%8B-Git-%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8">這篇文章</a>安裝 Git）<br>
<img src="https://sabrinajiang14.github.io//post-images/1574750125425.png" alt=""></p>
<h3 id="step-3">Step 3</h3>
<p>輸入 <code>bash ruby -v</code> 檢查是否有安裝 ruby<br>
<img src="https://sabrinajiang14.github.io//post-images/1574750190041.png" alt=""></p>
<h3 id="step-4">Step 4</h3>
<p>安裝brew，請輸入 <code>bash ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p>
<h3 id="step-5">Step 5</h3>
<p>安裝 Xcode ，畢竟 Appium 還是在 Xcode 的基礎上做測試，所以還是要安裝。</p>
<h3 id="step-6">Step 6</h3>
<p>安裝 node，請輸入 <code>bash brew install node</code><br>
但是在這一步一直失敗，訊息提示寫入失敗或是找不到這個資料夾。查了很多資料之後，發現應該是權限有問題，所以我先做以下步驟：</p>
<blockquote>
<p>。 移除 node : brew uninstall node<br>
。 權限重新設定：sudo chown -R $(whoami) $(brew — prefix)/*<br>
。 重新安裝 node：brew install node<br>
。 再重下指令：brew link node<br>
。 如果還是失敗，就改成：brew link — overwrite node</p>
</blockquote>
<p>再打一次 <code>bash node -v</code>，如果成功應該就會顯示下面的資訊<br>
<img src="https://sabrinajiang14.github.io//post-images/1574750699412.png" alt=""></p>
<h3 id="step-7">Step 7</h3>
<p>安裝 Appium</p>
<pre><code class="language-bash">npm install -g appium   #安裝Server
npm install wd          #安裝Client
</code></pre>
<p>另外，也可以裝個檢查器，檢查 Appium 是否安裝完成。</p>
<pre><code class="language-bash">npm install appium-doctor -g    #安裝檢查器
appium-doctor                   #進行檢查
</code></pre>
<p><img src="https://sabrinajiang14.github.io//post-images/1574751083574.png" alt=""><br>
<img src="https://sabrinajiang14.github.io//post-images/1574751088658.png" alt=""><br>
檢查器會將預計會用到的全部檢查一遍，就算不是全部都過，也不用擔心。只要確定自己要測試的那個平台的相關軟體有安裝完成就可以囉。</p>
<h3 id="step8">Step8</h3>
<p>安裝 Appium Desktop<br>
可以直接透過<a href="http://appium.io/">官網</a>下載或是到他們的 <a href="https://github.com/appium/appium-desktop/releases/download/v1.15.1/Appium-mac-1.15.1.dmg">Github</a> 去下載 Appium-mac-x.x.dmg（目前我看到最新版是這個，連結隨時都有可能換，還是從官網連過去最保險）</p>
<p>以上步驟如果都完成了，就可以打開 Appium Desktop<br>
<img src="https://sabrinajiang14.github.io//post-images/1574751218258.png" alt=""></p>
<p>點選 Start Server 後會顯示另外一個畫面。<br>
<img src="https://sabrinajiang14.github.io//post-images/1574751250657.png" alt=""></p>
<p>點下右上角的搜尋圖示 — Start Inspector Session<br>
<img src="https://sabrinajiang14.github.io//post-images/1574751270624.png" alt=""></p>
<p>在這個新的畫面上可以做一些設定，像我是要測試 iOS app。所以我就填上 platformName、platformVersion、autommationName等等相關訊息。（想知道有哪些關鍵字可以填，直接點下方的 Desired Capabilities Documentation 去查看）<br>
完成後可以將此次的測試資料儲存起來，以期下次在使用。點選 Start Session 後就會看到模擬器被啟動囉！<br>
（話說我還有實機的部分還沒有實作，等我實作完再上來補:P）</p>
<hr>
<p>今天這篇文章沒有寫的很專業，只能說是簡單的入門篇而已，希望有幫助到想要入門的朋友唷！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Swift] Observer Pattern - NSNotificationCenter]]></title>
        <id>https://sabrinajiang14.github.io//post/swift-observer-pattern-nsnotificationcenter</id>
        <link href="https://sabrinajiang14.github.io//post/swift-observer-pattern-nsnotificationcenter">
        </link>
        <updated>2017-04-13T07:38:56.000Z</updated>
        <content type="html"><![CDATA[<p>Swift 的觀察者模式實作：</p>
<pre><code class="language-swift">static let CHANGE_BACKGROUND_COLOR = &quot;changeBackgroundColor&quot;

func viewDidLoad(){
  super.viewDidLoad()
  
  //加入觀察者
  NSNotificationCenter.defaultCenter().addObserver(self, selector: #selector(changeBackgroundColor), name: CHANGE_BACKGROUND_COLOR, object: nil)
}

//移除觀察者
func viewWillDisappear(animated: Bool){
  NSNotificationCenter.defaultCenter().removeObserver(self, name: CHANGE_BACKGROUND_COLOR, object: nil)
}

//實作
func changeBackgroundColor(){
  self.view.backgroundColor = UIColor.redColor()
}
</code></pre>
<pre><code class="language-swift">func button_Click(){
  NSNotificationCenter.defaultCenter().postNotificationName(viewcontroller.CHANGE_BACKGROUND_COLOR, object: nil)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[OC] 如何簡單劃出一條線]]></title>
        <id>https://sabrinajiang14.github.io//post/oc-ru-he-jian-dan-hua-chu-yi-tiao-xian</id>
        <link href="https://sabrinajiang14.github.io//post/oc-ru-he-jian-dan-hua-chu-yi-tiao-xian">
        </link>
        <updated>2016-07-20T07:35:18.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-objective-c">UIImageView *imageView1 = [[UIImageView alloc]initWithFrame:CGRectMake(0, 200, 320, 20)];
[self.view addSubview:imageView1];

UIGraphicsBeginImageContext(imageView1.frame.size);   //开始画线
[imageView1.image drawInRect:CGRectMake(0, 0, imageView1.frame.size.width, imageView1.frame.size.height)];
CGContextSetLineCap(UIGraphicsGetCurrentContext(), kCGLineCapRound);  //设置线条终点形状
    
const CGFloat lengths[] = {5,3};
CGContextRef line = UIGraphicsGetCurrentContext();
CGContextSetStrokeColorWithColor(line, [UIColor redColor].CGColor);

CGContextSetLineDash(line, 0, lengths, 2);  //画虚线
CGContextMoveToPoint(line, 0.0, 20.0);    //开始画线
CGContextAddLineToPoint(line, 310.0, 20.0);
CGContextStrokePath(line);

imageView1.image = UIGraphicsGetImageFromCurrentImageContext();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[OC] New UIAlertController]]></title>
        <id>https://sabrinajiang14.github.io//post/oc-new-uialertcontroller</id>
        <link href="https://sabrinajiang14.github.io//post/oc-new-uialertcontroller">
        </link>
        <updated>2016-03-07T07:32:09.000Z</updated>
        <content type="html"><![CDATA[<p>今年開始 Alert view 有新的寫法了。</p>
<p>需要改成用 UIAlertController 的方式去實作，不然就會得到警告喔！</p>
<pre><code class="language-objective-c">UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;刪除&quot; message:@&quot;確定要刪除？&quot; preferredStyle:UIAlertControllerStyleAlert];
UIAlertAction *sureAction = [UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * action) {
  //裡面實作
}];
UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@&quot;Cancel&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * action) {
  //裡面實作
}];
[alert addAction:sureAction];
[alert addAction:cancelAction];
[self presentViewController:alert animated:YES completion:nil];
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[OC] 如何切字串]]></title>
        <id>https://sabrinajiang14.github.io//post/oc-ru-he-qie-zi-chuan</id>
        <link href="https://sabrinajiang14.github.io//post/oc-ru-he-qie-zi-chuan">
        </link>
        <updated>2016-03-07T07:26:48.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-objective-c">NSString類別裡，總共有三種切字串的方法
1. - (NSString *)substringFromIndex:(NSUInteger)anIndex
2. - (NSString *)substringToIndex:(NSUInteger)anIndex
3. - (NSString *)substringWithRange:(NSRange)aRange

==================
NSString *str = @&quot;1234567890&quot;;  
NSLog(@&quot;Original String: %@&quot;, str);  
NSLog(@&quot;substringFromIndex: 5 ==&gt; %@&quot;, [str substringFromIndex:5]);  
NSLog(@&quot;substringToIndex: 5 ==&gt; %@&quot;, [str substringToIndex:5]);  
NSLog(@&quot;substringWithRange: from 7, length 3 ==&gt; %@&quot;, [str substringWithRange:NSMakeRange(7, 3)]); 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[OC] UISearchController 的用法]]></title>
        <id>https://sabrinajiang14.github.io//post/oc-uisearchcontroller-de-yong-fa</id>
        <link href="https://sabrinajiang14.github.io//post/oc-uisearchcontroller-de-yong-fa">
        </link>
        <updated>2016-03-03T07:29:15.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-objective-c">@interface SearchAddressController : UIViewController&lt;UISearchControllerDelegate, UISearchDisplayDelegate, UISearchBarDelegate, UITableViewDataSource, UITableViewDelegate&gt;

@property (weak, nonatomic) IBOutlet UITableView *contectTable;
@property (nonatomic, strong) UISearchController *searchController;
</code></pre>
<pre><code class="language-objective-c">- (void)viewDidLoad {
    self.searchController = [[UISearchController alloc] initWithSearchResultsController:nil];
    self.searchController.searchResultsUpdater = self;
    self.searchController.dimsBackgroundDuringPresentation = NO;
    self.searchController.searchBar.scopeButtonTitles = @[];
    self.searchController.searchBar.delegate = self;
    self.contectTable.tableHeaderView = self.searchController.searchBar;
    [self.searchController.searchBar sizeToFit];
    self.definesPresentationContext = YES;
}

#pragma mark - UISearchController delegate
- (void)updateSearchResultsForSearchController:(UISearchController *)searchController
{
    NSString *searchString = searchController.searchBar.text;
    if (searchString.length != 0) {
        shouldShowSearchResults = true;
        NSPredicate *resultPredicate = [NSPredicate predicateWithFormat:@&quot;self CONTAINS[c] %@&quot;, searchString];
        searchResultArray = [addressArray filteredArrayUsingPredicate:resultPredicate];
        [self.contectTable reloadData];
    }else{
        shouldShowSearchResults = false;
        [self.contectTable reloadData];
    }
}

- (void)searchBar:(UISearchBar *)searchBar selectedScopeButtonIndexDidChange:(NSInteger)selectedScope
{
    [self updateSearchResultsForSearchController:self.searchController];
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[OC] UIColor，UIImage 互轉]]></title>
        <id>https://sabrinajiang14.github.io//post/oc-uicoloruiimage-hu-zhuan</id>
        <link href="https://sabrinajiang14.github.io//post/oc-uicoloruiimage-hu-zhuan">
        </link>
        <updated>2015-11-04T07:22:06.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-objective-c">//UIColor 轉 UIImage 
- (UIImage*) createImageWithColor: (UIColor*) color  
    {  
        CGRect rect=CGRectMake(0,0, 1, 1);  
        UIGraphicsBeginImageContext(rect.size);  
        CGContextRef context = UIGraphicsGetCurrentContext();  
        CGContextSetFillColorWithColor(context, [color CGColor]);  
        CGContextFillRect(context, rect);  
        UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext();  
        UIGraphicsEndImageContext();  
        return theImage;  
    } 


//UIImage轉UIColor
[UIColor colorWithPatternImage:[UIImageimageNamed:@“bg.png&quot;]] 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[OC] 使用客製化物件的時間屬性做排序]]></title>
        <id>https://sabrinajiang14.github.io//post/oc-shi-yong-ke-zhi-hua-wu-jian-de-shi-jian-shu-xing-zuo-pai-xu</id>
        <link href="https://sabrinajiang14.github.io//post/oc-shi-yong-ke-zhi-hua-wu-jian-de-shi-jian-shu-xing-zuo-pai-xu">
        </link>
        <updated>2015-09-02T07:13:52.000Z</updated>
        <content type="html"><![CDATA[<p>這幾天要做一個物件的排序，結果發現 OC 的排序只能針對基本型別做排序，<br>
如果我的 array 是放 customer object 就必須要另外實作。<br>
這實在讓我太苦惱了啊~~~</p>
<pre><code class="language-objective-c">NSArray *arrRestaurantQueue = [[dicResult objectForKey:@&quot;RestaurantRsv&quot;] sortedArrayUsingComparator:^NSComparisonResult(QDReservation *obj1, QDReservation *obj2) {
  NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
  [dateFormatter setDateFormat:@&quot;yyyy-MM-dd HH:mm&quot;];
  NSDate *date1 = [dateFormatter dateFromString:obj1.rsvTime];
  NSDate *date2 = [dateFormatter dateFromString:obj2.rsvTime];
                
  if ([date1 compare:date2] == NSOrderedDescending) {
    return (NSComparisonResult)NSOrderedDescending;
  } else if ([date1 compare:date2] == NSOrderedAscending) {
    return (NSComparisonResult)NSOrderedAscending;
  } else {
    return (NSComparisonResult)NSOrderedSame;
  }
}];
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[OC] 比較兩個時間差]]></title>
        <id>https://sabrinajiang14.github.io//post/oc-bi-jiao-liang-shi-jian-chai</id>
        <link href="https://sabrinajiang14.github.io//post/oc-bi-jiao-liang-shi-jian-chai">
        </link>
        <updated>2015-04-09T07:07:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="直接返回兩者時間差">直接返回兩者時間差</h2>
<pre><code class="language-objective-c">-(NSTimeInterval)compareTwoTimes:(NSString *)sExpDate {
  NSDateFormatter *formatter = [[NSDateFormatter alloc]init];
  [formatter setDateFormat:@&quot;yyyy/MM/dd HH:mm:ss&quot;];
  NSDate *tempDate = [formatter dateFromString:sExpDate];
  NSDate *nowDate = [NSDate date];
  NSTimeInterval difftime = [tempDate timeIntervalSinceDate:nowDate];
  return difftime
}
</code></pre>
<hr>
<h2 id="直接返回字串">直接返回字串</h2>
<pre><code class="language-objective-c">-(NSString *) compareCurrentTime:(NSDate*) compareDate {
    NSTimeInterval  timeInterval = [compareDate timeIntervalSinceNow];
    timeInterval = -timeInterval;
    long temp = 0;
    NSString *result;
    if (timeInterval &lt; 60) {
        result = [NSString stringWithFormat:@&quot;剛剛&quot;];
    }
    else if((temp = timeInterval/60) &lt;60){
        result = [NSString stringWithFormat:@&quot;%ld分鐘前&quot;,temp];
    }
    
    else if((temp = temp/60) &lt;24){
        result = [NSString stringWithFormat:@&quot;%ld小時前&quot;,temp];
    }
    
    else if((temp = temp/24) &lt;30){
        result = [NSString stringWithFormat:@&quot;%ld天前&quot;,temp];
    }
    
    else if((temp = temp/30) &lt;12){
        result = [NSString stringWithFormat:@&quot;%ld月前&quot;,temp];
    }

    else{
        temp = temp/12;
        result = [NSString stringWithFormat:@&quot;%ld年前&quot;,temp];
    }
    
    return  result;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[OC] UITextField 的使用方式]]></title>
        <id>https://sabrinajiang14.github.io//post/oc-uitextfield-de-shi-yong-fang-shi</id>
        <link href="https://sabrinajiang14.github.io//post/oc-uitextfield-de-shi-yong-fang-shi">
        </link>
        <updated>2015-03-24T07:02:16.000Z</updated>
        <content type="html"><![CDATA[<p>最近在寫 UITextFiled 的時候發現它有很多 delegate method 可以使用，筆記一下：</p>
<pre><code class="language-objective-c">#import &lt;UIKit/UIKit.h&gt;

@interface ViewController : UIViewController&lt;UITextFieldDelegate&gt;//TextField的協定

@end
</code></pre>
<pre><code class="language-objective-c">#import &quot;ViewController.h&quot;

@interface ViewController () {
    UITextField *your_textfield_1;
    UITextField *your_textfield_2;
}

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    //設置一個普通的UITextField
    your_textfield_1 = [[UITextField alloc]initWithFrame:CGRectMake(20, 40, 250, 40)];//初始化TextField的物件並設置位置與大小
    your_textfield_1.delegate = self;//設定給代理才可使用協定
    your_textfield_1.borderStyle = UITextBorderStyleLine;//設定樣式
    
    /*
     UITextBorderStyleNone無樣式
     UITextBorderStyleLine黑色格線
     UITextBorderStyleBezel灰色格線
     UITextBorderStyleRoundedRect普通圓角框
     */
    
    your_textfield_1.font = [UIFont fontWithName:@&quot;Arial&quot; size:20.0f];//字體的大小以及字型
    your_textfield_1.textColor = [UIColor blueColor];//字體顏色
    your_textfield_1.backgroundColor = [UIColor yellowColor];//背景顏色
    your_textfield_1.placeholder = @&quot;普通的TextField&quot;;//設置提示的字
    your_textfield_1.autocorrectionType = UITextAutocorrectionTypeNo;//是不是要訂正輸入的字
    
    /*
     UITextAutocorrectionTypeDefault,默認
     UITextAutocorrectionTypeNo,不自動出現訂正的字
     UITextAutocorrectionTypeYes,自動出現訂正的字
     */
    
    your_textfield_1.textAlignment = NSTextAlignmentLeft;//水平對齊方式
    your_textfield_1.contentVerticalAlignment = UIControlContentVerticalAlignmentCenter;//垂直對齊方式
    your_textfield_1.clearButtonMode = UITextFieldViewModeUnlessEditing;//設定&quot;刪除內文&quot;的按鈕選項
    
    /*
     UITextFieldViewModeNever,設定不會出現
     UITextFieldViewModeWhileEditing,編輯時才出現
     UITextFieldViewModeUnlessEditing,編輯時不出現
     UITextFieldViewModeAlways總是出現
     */
    
    your_textfield_1.secureTextEntry = NO;//將輸入的內文設置&quot;*&quot;
    your_textfield_1.clearsOnBeginEditing = NO;//再次編輯的時候將內容直接清除
    your_textfield_1.keyboardType = UIKeyboardTypeDefault;//鍵盤的樣式
    
    /*
     UIKeyboardTypeDefault,普通鍵盤樣式
     UIKeyboardTypeASCIICapable,支持ASCII的鍵盤樣式
     UIKeyboardTypeNumbersAndPunctuation,數字鍵盤有支持＋＊＃等字
     UIKeyboardTypeURL,輸入網址時方便的鍵盤
     UIKeyboardTypeNumberPad,數字鍵盤
     UIKeyboardTypePhonePad,電話鍵盤
     UIKeyboardTypeNamePhonePad,電話鍵盤可切換至英文
     UIKeyboardTypeEmailAddress,用於輸入電子郵件的鍵盤
     UIKeyboardTypeDecimalPad,小數點以及數字鍵盤
     UIKeyboardTypeTwitter, 優化的鍵盤，方便输入@、#字符
     */
    
    your_textfield_1.autocapitalizationType = UITextAutocapitalizationTypeNone;//字母是否大寫
    
    /*
     UITextAutocapitalizationTypeNone,不自動大寫
     UITextAutocapitalizationTypeWords,單字的首字大寫
     UITextAutocapitalizationTypeSentences,句字的首字大寫
     UITextAutocapitalizationTypeAllCharacters,所有字母大寫
     */
    
    your_textfield_1.returnKeyType =UIReturnKeyDefault;//return键樣式
    
    /*
     UIReturnKeyDefault,有Return字符的鍵
     UIReturnKeyDone.有Done字符的藍色按钮
     UIReturnKeyGo,有GO字符的藍色按钮
     UIReturnKeyGoogle,有Google字符的藍色按钮
     UIReturnKeyJoin,有Join字符的藍色按钮
     UIReturnKeyNext,有Next的藍色按钮
     UIReturnKeyRoute,有Route的藍色按钮
     UIReturnKeySearch,有Search的藍色按钮
     UIReturnKeySend,有Send的藍色按钮
     UIReturnKeyYahoo,有Yahoo的藍色按钮
     UIReturnKeyEmergencyCall,緊急呼叫按钮
     */
    
    your_textfield_1.keyboardAppearance=UIKeyboardAppearanceAlert;//鍵盤外觀
    
    /*
     UIKeyboardAppearanceDefault，淺灰色
     UIKeyboardAppearanceAlert，石墨色
     */
    
    [self.view addSubview:your_textfield_1];//加入至view中
    
    
    //設置有圖片背景以及內文圖的UITextField
    your_textfield_2 = [[UITextField alloc]initWithFrame:CGRectMake(20, 100, 250, 40)];//初始化TextField的物件並設置位置與大小
    your_textfield_2.delegate=self;//設定給代理才可使用協定
    your_textfield_2.borderStyle = UITextBorderStyleNone;//設定UITextBorderStyleNone樣式自由度更高
    your_textfield_2.font = [UIFont fontWithName:@&quot;Arial&quot; size:20.0f];//字體的大小以及字型
    your_textfield_2.placeholder = @&quot;有圖片的的TextField&quot;;//設置提示的字
    your_textfield_2.textAlignment = NSTextAlignmentLeft;//水平對齊方式
    your_textfield_2.contentVerticalAlignment = UIControlContentVerticalAlignmentCenter;//垂直對齊方式
    
    UIImageView *image=[[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;title.png&quot;]];//初始化UIImageView的物件，並設置圖片
    your_textfield_2.leftView=image;//設定圖片在左邊，也可設置右邊
    your_textfield_2.leftViewMode = UITextFieldViewModeAlways;//圖片出現的時機
    
    /*
     UITextFieldViewModeNever,設定不會出現
     UITextFieldViewModeWhileEditing編輯狀態才出現
     UITextFieldViewModeUnlessEditing編輯狀態不出現
     UITextFieldViewModeAlways總是出現
     */
    
    your_textfield_2.background=[UIImage imageNamed:@&quot;back.png&quot;];
    [self.view addSubview:your_textfield_2];//加入至view中
}

//協定裡的動作設定以及觸發方式
//開始編輯的時候會觸發，可設定一些動作在此
- (void)textFieldDidBeginEditing:(UITextField *)textField{
    
    NSLog(@&quot;start&quot;);
    
}

//按下&quot;clearButtonMode&quot;的按鈕會觸發
- (BOOL)textFieldShouldClear:(UITextField *)textField{
    
    NSLog(@&quot;clear&quot;);
    
    return YES;
    
}

//結束編輯時會觸發，傳回BOOL值，可在編輯模式中確定是否要離開編輯模式
- (BOOL)textFieldShouldEndEditing:(UITextField *)textField{
    
    NSLog(@&quot;over&quot;);
    return YES;//return NO 就會一直在編輯模式
    
}

//按下Return鍵的反應
-(BOOL)textFieldShouldReturn:(UITextField *)textField{
    
    //縮起鍵盤
    [textField resignFirstResponder];
    return YES;
    
}

//傳回BOOL值，指定是否循序內文字段編輯
- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField{
    return YES;
}

//限制使用者只能輸入的字串

-(BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string{
    
    NSCharacterSet *cs = [[NSCharacterSet characterSetWithCharactersInString:kAlphaNum]invertedSet];//kAlphaNum要先定義才能使用，限定可出現的字符
    
    NSString *filtered = [[string componentsSeparatedByCharactersInSet:cs]componentsJoinedByString:@&quot;=&quot;];//不再限定範圍內又可以出現的字符
    
    BOOL canChange = [string isEqualToString:filtered];
    return canChange;
    
}

//限制使用者能輸入的總數

- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string {
    
    //可限定哪些字元可超過 return YES 就是可以輸入文字
    
    if ([string isEqualToString:@&quot;A&quot;]){
        
        return YES;
        
    }
    
    NSString * toBeString = [textField.text stringByReplacingCharactersInRange:range withString:string];//取得輸入框內容 用於計算輸入框的總數
    
    if (your_textfield_1 == textField){ //應用於想使用的輸入框上
        
        if ([toBeString length] &gt; 10) { //超過10個跳出警告
            
            your_textfield_1 = [toBeString substringToIndex:10];
            
            UIAlertView *alert = [[UIAlertView alloc] initWithTitle:nil message:@&quot;無法輸入 已超過上線&quot; delegate:nil cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil, nil];
            
            [alert show];
            return NO;
        }
    }
    return YES;
    
}

@end
</code></pre>
]]></content>
    </entry>
</feed>